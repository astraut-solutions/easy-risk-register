import type { Risk } from '../types/risk';

export interface VulnerabilityScannerConfig {
  scannerType: 'openvas' | 'zap' | 'nikto';
}

export interface Vulnerability {
  id: string;
  name: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  cvssScore?: number;
  description: string;
  solution?: string;
  urls?: string[];
  cveIds?: string[];
  firstSeen: string; // ISO date
  lastSeen?: string; // ISO date
  status: 'open' | 'confirmed' | 'fixed' | 'false_positive';
}

export interface ScanResult {
  scanId: string;
  target: string;
  startTime: string; // ISO date
  endTime?: string; // ISO date
  status: 'running' | 'completed' | 'failed' | 'cancelled';
  vulnerabilities: Vulnerability[];
}

type VulnerabilityScannerFeatureFlags = {
  enabled: boolean;
  apiBaseUrl: string;
};

const getScannerFlags = (): VulnerabilityScannerFeatureFlags => ({
  enabled: import.meta.env.VITE_ENABLE_VULN_SCANNER === 'true',
  apiBaseUrl: import.meta.env.VITE_API_BASE_URL || '',
});

/**
 * Service for integrating with vulnerability scanners.
 *
 * Security policy:
 * - Feature-flagged (off by default)
 * - Credentials must be stored server-side only
 * - Frontend only calls `/api/vuln-scanner/*` routes
 */
export class VulnerabilityScannerService {
  private config: VulnerabilityScannerConfig;

  constructor(config: VulnerabilityScannerConfig) {
    this.config = config;
  }

  private async postJson<T>(path: string, body: unknown): Promise<T | null> {
    const flags = getScannerFlags();
    if (!flags.enabled) return null;

    try {
      const res = await fetch(`${flags.apiBaseUrl}${path}`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(body ?? {}),
      });
      if (!res.ok) return null;
      return (await res.json()) as T;
    } catch {
      return null;
    }
  }

  async connect(): Promise<boolean> {
    const flags = getScannerFlags();
    if (!flags.enabled) return false;
    const result = await this.postJson<{ ok: boolean }>('/api/vuln-scanner/ping', {
      scannerType: this.config.scannerType,
    });
    return Boolean(result?.ok);
  }

  async fetchVulnerabilities(target?: string): Promise<Vulnerability[]> {
    const flags = getScannerFlags();
    if (!flags.enabled) return [];
    return (
      (await this.postJson<Vulnerability[]>('/api/vuln-scanner/vulnerabilities', {
        scannerType: this.config.scannerType,
        target: target ?? null,
      })) ?? []
    );
  }

  async startScan(target: string): Promise<string> {
    const flags = getScannerFlags();
    if (!flags.enabled) return '';
    const result = await this.postJson<{ scanId: string }>('/api/vuln-scanner/start', {
      scannerType: this.config.scannerType,
      target,
    });
    return typeof result?.scanId === 'string' ? result.scanId : '';
  }

  async getScanResults(scanId: string): Promise<ScanResult | null> {
    const flags = getScannerFlags();
    if (!flags.enabled) return null;
    return await this.postJson<ScanResult>('/api/vuln-scanner/results', {
      scannerType: this.config.scannerType,
      scanId,
    });
  }

  vulnerabilitiesToRisks(vulnerabilities: Vulnerability[]): Partial<Risk>[] {
    return vulnerabilities.map((vuln) => {
      let probability = 3;
      let impact = 3;

      switch (vuln.severity) {
        case 'critical':
          probability = 4;
          impact = 5;
          break;
        case 'high':
          probability = 4;
          impact = 4;
          break;
        case 'medium':
          probability = 3;
          impact = 3;
          break;
        case 'low':
          probability = 2;
          impact = 2;
          break;
      }

      const riskScore = probability * impact;

      return {
        title: vuln.name,
        description: vuln.description,
        probability,
        impact,
        riskScore,
        category: 'Vulnerability',
        threatType: 'vulnerability',
        status: 'open',
        mitigationPlan: vuln.solution || 'Apply the recommended solution',
        evidence:
          vuln.urls?.map((url) => ({
            type: 'link' as const,
            url,
            description: `Vulnerability reference for ${vuln.name}`,
          })) || [],
        creationDate: new Date().toISOString(),
        lastModified: new Date().toISOString(),
      };
    });
  }
}

export const createVulnerabilityScannerService = (config: VulnerabilityScannerConfig) =>
  new VulnerabilityScannerService(config);

