import type { Risk } from '../types/risk';

interface VulnerabilityScannerConfig {
  scannerType: 'openvas' | 'zap' | 'nikto';
  baseUrl: string;
  apiKey?: string;
  username?: string;
  password?: string;
  headers?: Record<string, string>;
}

interface Vulnerability {
  id: string;
  name: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  cvssScore?: number;
  description: string;
  solution?: string;
  urls?: string[];
  cveIds?: string[];
  firstSeen: string; // ISO date
  lastSeen?: string; // ISO date
  status: 'open' | 'confirmed' | 'fixed' | 'false_positive';
}

interface ScanResult {
  scanId: string;
  target: string;
  startTime: string; // ISO date
  endTime?: string; // ISO date
  status: 'running' | 'completed' | 'failed' | 'cancelled';
  vulnerabilities: Vulnerability[];
}

interface OpenVasConfig extends VulnerabilityScannerConfig {
  scannerType: 'openvas';
  username: string;
  password: string;
}

interface ZapConfig extends VulnerabilityScannerConfig {
  scannerType: 'zap';
  apiKey: string;
}

interface NiktoConfig extends VulnerabilityScannerConfig {
  scannerType: 'nikto';
  // Nikto typically runs locally via command line
  // For API integration, we might use a wrapper service
}

/**
 * Service for integrating with vulnerability scanners (OpenVAS, ZAP, Nikto)
 */
export class VulnerabilityScannerService {
  private config: VulnerabilityScannerConfig;

  constructor(config: VulnerabilityScannerConfig) {
    this.config = config;
  }

  /**
   * Connect to the vulnerability scanner
   */
  async connect(): Promise<boolean> {
    try {
      switch (this.config.scannerType) {
        case 'openvas':
          return await this.connectToOpenVAS();
        case 'zap':
          return await this.connectToZAP();
        case 'nikto':
          return await this.connectToNikto();
        default:
          throw new Error(`Unsupported scanner type: ${this.config.scannerType}`);
      }
    } catch (error) {
      console.error(`Failed to connect to ${this.config.scannerType}:`, error);
      return false;
    }
  }

  /**
   * Fetch vulnerabilities from the scanner
   */
  async fetchVulnerabilities(target?: string): Promise<Vulnerability[]> {
    try {
      switch (this.config.scannerType) {
        case 'openvas':
          return await this.fetchVulnerabilitiesFromOpenVAS(target);
        case 'zap':
          return await this.fetchVulnerabilitiesFromZAP(target);
        case 'nikto':
          return await this.fetchVulnerabilitiesFromNikto(target);
        default:
          throw new Error(`Unsupported scanner type: ${this.config.scannerType}`);
      }
    } catch (error) {
      console.error(`Failed to fetch vulnerabilities from ${this.config.scannerType}:`, error);
      throw error;
    }
  }

  /**
   * Start a new vulnerability scan
   */
  async startScan(target: string): Promise<string> {
    try {
      switch (this.config.scannerType) {
        case 'openvas':
          return await this.startOpenVASScan(target);
        case 'zap':
          return await this.startZAPScan(target);
        case 'nikto':
          return await this.startNiktoScan(target);
        default:
          throw new Error(`Unsupported scanner type: ${this.config.scannerType}`);
      }
    } catch (error) {
      console.error(`Failed to start scan with ${this.config.scannerType}:`, error);
      throw error;
    }
  }

  /**
   * Get scan results by scan ID
   */
  async getScanResults(scanId: string): Promise<ScanResult> {
    try {
      switch (this.config.scannerType) {
        case 'openvas':
          return await this.getOpenVASScanResults(scanId);
        case 'zap':
          return await this.getZAPScanResults(scanId);
        case 'nikto':
          return await this.getNiktoScanResults(scanId);
        default:
          throw new Error(`Unsupported scanner type: ${this.config.scannerType}`);
      }
    } catch (error) {
      console.error(`Failed to get scan results from ${this.config.scannerType}:`, error);
      throw error;
    }
  }

  /**
   * Convert vulnerabilities to risk objects for the risk register
   */
  vulnerabilitiesToRisks(vulnerabilities: Vulnerability[]): Partial<Risk>[] {
    return vulnerabilities.map(vuln => {
      // Map vulnerability severity to risk probability and impact
      let probability = 3; // Default to medium
      let impact = 3; // Default to medium
      
      switch (vuln.severity) {
        case 'critical':
          probability = 4;
          impact = 5;
          break;
        case 'high':
          probability = 4;
          impact = 4;
          break;
        case 'medium':
          probability = 3;
          impact = 3;
          break;
        case 'low':
          probability = 2;
          impact = 2;
          break;
      }

      // Calculate risk score (probability * impact)
      const riskScore = probability * impact;

      return {
        title: vuln.name,
        description: vuln.description,
        probability,
        impact,
        riskScore,
        category: 'Vulnerability',
        threatType: 'vulnerability',
        status: 'open',
        mitigationPlan: vuln.solution || 'Apply the recommended solution',
        evidence: vuln.urls?.map(url => ({
          type: 'link' as const,
          url,
          description: `Vulnerability reference for ${vuln.name}`
        })) || [],
        creationDate: new Date().toISOString(),
        lastModified: new Date().toISOString(),
      };
    });
  }

  // OpenVAS-specific methods
  private async connectToOpenVAS(): Promise<boolean> {
    // OpenVAS API connection logic
    const response = await fetch(`${this.config.baseUrl}/api/roles`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...this.config.headers,
        // OpenVAS typically uses basic auth
        'Authorization': `Basic ${btoa(`${this.config.username}:${this.config.password}`)}`
      }
    });

    return response.ok;
  }

  private async fetchVulnerabilitiesFromOpenVAS(target?: string): Promise<Vulnerability[]> {
    // Fetch vulnerabilities from OpenVAS
    // This is a simplified implementation - real OpenVAS API is more complex
    const response = await fetch(`${this.config.baseUrl}/api/vulnerabilities`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...this.config.headers,
        'Authorization': `Basic ${btoa(`${this.config.username}:${this.config.password}`)}`
      }
    });

    if (!response.ok) {
      throw new Error(`OpenVAS API error: ${response.status}`);
    }

    const data = await response.json();
    
    // Map OpenVAS response to our Vulnerability interface
    return data.vulnerabilities?.map((v: any) => ({
      id: v.id || v.uuid,
      name: v.name || v.nvt?.name,
      severity: this.mapOpenVASSeverity(v.threat || v.severity),
      cvssScore: parseFloat(v.cvss_base) || parseFloat(v.cvss),
      description: v.description || v.nvt?.summary || '',
      solution: v.solution || v.nvt?.solution,
      urls: v.vuln_refs?.ref ? Array.isArray(v.vuln_refs.ref) ? v.vuln_refs.ref : [v.vuln_refs.ref] : [],
      cveIds: v.vuln_refs?.cve ? Array.isArray(v.vuln_refs.cve) ? v.vuln_refs.cve : [v.vuln_refs.cve] : [],
      firstSeen: v.creation_time || new Date().toISOString(),
      lastSeen: v.modification_time,
      status: this.mapOpenVASStatus(v.status)
    })) || [];
  }

  private async startOpenVASScan(target: string): Promise<string> {
    // Start a new OpenVAS scan
    const response = await fetch(`${this.config.baseUrl}/api/scans`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...this.config.headers,
        'Authorization': `Basic ${btoa(`${this.config.username}:${this.config.password}`)}`
      },
      body: JSON.stringify({
        target,
        // Additional scan configuration would go here
      })
    });

    if (!response.ok) {
      throw new Error(`OpenVAS start scan error: ${response.status}`);
    }

    const data = await response.json();
    return data.scan_id || data.id;
  }

  private async getOpenVASScanResults(scanId: string): Promise<ScanResult> {
    // Get OpenVAS scan results
    const response = await fetch(`${this.config.baseUrl}/api/scans/${scanId}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...this.config.headers,
        'Authorization': `Basic ${btoa(`${this.config.username}:${this.config.password}`)}`
      }
    });

    if (!response.ok) {
      throw new Error(`OpenVAS get scan results error: ${response.status}`);
    }

    const data = await response.json();
    
    return {
      scanId,
      target: data.target || '',
      startTime: data.start_time || new Date().toISOString(),
      endTime: data.end_time,
      status: this.mapOpenVASStatus(data.status),
      vulnerabilities: await this.fetchVulnerabilitiesFromOpenVAS()
    };
  }

  // ZAP-specific methods
  private async connectToZAP(): Promise<boolean> {
    // ZAP API connection logic
    const response = await fetch(`${this.config.baseUrl}/JSON/core/action/version/?apikey=${this.config.apiKey}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...this.config.headers
      }
    });

    return response.ok;
  }

  private async fetchVulnerabilitiesFromZAP(target?: string): Promise<Vulnerability[]> {
    // Fetch alerts from ZAP
    const response = await fetch(
      `${this.config.baseUrl}/JSON/core/view/alerts/?apikey=${this.config.apiKey}${target ? `&url=${encodeURIComponent(target)}` : ''}`,
      {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          ...this.config.headers
        }
      }
    );

    if (!response.ok) {
      throw new Error(`ZAP API error: ${response.status}`);
    }

    const data = await response.json();
    
    return data.alerts?.map((alert: any) => ({
      id: alert.id,
      name: alert.alert || 'Unknown Alert',
      severity: this.mapZAPSeverity(alert.riskcode),
      cvssScore: parseFloat(alert.cweid) ? this.calculateCVSSFromCWE(alert.cweid) : undefined,
      description: alert.description || '',
      solution: alert.solution || alert.otherinfo,
      urls: [alert.url],
      cveIds: alert.cweid ? [`CWE-${alert.cweid}`] : [],
      firstSeen: new Date().toISOString(), // ZAP doesn't provide this directly
      status: 'open'
    })) || [];
  }

  private async startZAPScan(target: string): Promise<string> {
    // Start a ZAP spider scan
    const response = await fetch(
      `${this.config.baseUrl}/JSON/spider/action/scan/?apikey=${this.config.apiKey}&url=${encodeURIComponent(target)}`,
      {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          ...this.config.headers
        }
      }
    );

    if (!response.ok) {
      throw new Error(`ZAP start scan error: ${response.status}`);
    }

    const data = await response.json();
    return data.scan;
  }

  private async getZAPScanResults(scanId: string): Promise<ScanResult> {
    // Get ZAP scan results
    const response = await fetch(
      `${this.config.baseUrl}/JSON/spider/view/status/?apikey=${this.config.apiKey}&scanId=${scanId}`,
      {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          ...this.config.headers
        }
      }
    );

    if (!response.ok) {
      throw new Error(`ZAP get scan results error: ${response.status}`);
    }

    const data = await response.json();
    
    return {
      scanId,
      target: '', // Would need to track this separately
      startTime: new Date().toISOString(), // ZAP doesn't provide this directly
      status: data.status === '100' ? 'completed' : 'running',
      vulnerabilities: await this.fetchVulnerabilitiesFromZAP()
    };
  }

  // Nikto-specific methods
  private async connectToNikto(): Promise<boolean> {
    // Nikto typically runs via command line, so we'd need a service wrapper
    // For now, just return true to indicate we can potentially run Nikto
    return true;
  }

  private async fetchVulnerabilitiesFromNikto(target?: string): Promise<Vulnerability[]> {
    // In a real implementation, this would call a Nikto wrapper service
    // For now, return an empty array
    console.warn('Nikto integration requires a backend service to execute Nikto scans');
    return [];
  }

  private async startNiktoScan(target: string): Promise<string> {
    // In a real implementation, this would call a Nikto wrapper service
    console.warn('Nikto integration requires a backend service to execute Nikto scans');
    return `nikto-${Date.now()}`;
  }

  private async getNiktoScanResults(scanId: string): Promise<ScanResult> {
    // In a real implementation, this would call a Nikto wrapper service
    console.warn('Nikto integration requires a backend service to execute Nikto scans');
    return {
      scanId,
      target: '',
      startTime: new Date().toISOString(),
      status: 'completed',
      vulnerabilities: []
    };
  }

  // Helper methods
  private mapOpenVASSeverity(threat: string): Vulnerability['severity'] {
    switch (threat?.toLowerCase()) {
      case 'high':
      case 'critical':
        return 'critical';
      case 'medium':
        return 'high';
      case 'low':
        return 'medium';
      default:
        return 'low';
    }
  }

  private mapOpenVASStatus(status: string): Vulnerability['status'] {
    switch (status?.toLowerCase()) {
      case 'fixed':
      case 'resolved':
        return 'fixed';
      case 'confirmed':
        return 'confirmed';
      case 'false positive':
      case 'false_positive':
        return 'false_positive';
      default:
        return 'open';
    }
  }

  private mapZAPSeverity(riskcode: string): Vulnerability['severity'] {
    // ZAP uses 0=Informational, 1=Low, 2=Medium, 3=High, 4=Critical
    switch (riskcode) {
      case '4':
        return 'critical';
      case '3':
        return 'high';
      case '2':
        return 'medium';
      case '1':
        return 'low';
      default:
        return 'low';
    }
  }

  private calculateCVSSFromCWE(cweid: string): number {
    // This is a simplified calculation - in reality, you'd need to map CWE to CVSS vectors
    // For demonstration purposes, return a default score based on CWE category
    const highRiskCWEs = ['79', '89', '78', '611']; // XSS, SQL Injection, Command Injection, XXE
    if (highRiskCWEs.includes(cweid)) {
      return 8.0;
    }
    return 5.0; // Default medium
  }
}

// Convenience function to create a vulnerability scanner service
export const createVulnerabilityScannerService = (config: VulnerabilityScannerConfig) => {
  return new VulnerabilityScannerService(config);
};